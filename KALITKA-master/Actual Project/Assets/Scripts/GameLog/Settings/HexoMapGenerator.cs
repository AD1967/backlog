using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public class HexoMapGenerator : MonoBehaviour
{
    public static bool turn = false; // Информация о том, чей ход. 
    // false -- синего
    // true -- красного
    public static int turn_count = 0;// Информация о том сколько ходов осталось сделать 

    public static int n = 3, m = n; // Это размеры карты, к которым иногда нужно обращаться
        // Изначальный размер карты 6х6, но в настройках есть поле, с помощью которого размеры можно поменять

    public static float block_lenght = 2.0f, r = 0.2f;
        // block_lenght - это длина блока (нужно для генерации карты)
        // r - расстояние между блоками
    
    public struct Square // Структура Square - то есть единица игрового поля (у нас это кубы).
    {
        public int level, owner;
            // level - это уровень куба
            // owner - обладатель куба (-1 - у блока нет владельца, 0 - владелец синий, 1 - владелец красный)
    }

    public GameObject block; // модель гексогона сюда 

    public static Square[,] map = new Square[n, m]; // Матрица блоков -- то есть сама карта, в которой хранится информация о каждом блоке.
        // У блоков есть свой индекс, которых хранится в переменных a, b в самих блоках.
        // Если что, матрица здесь -- это двумерный массив.
    // Это пошли переменные, необходимые для генерации карты с распределенным рандомом
    void Start()
    {
        if(MapGenerator.type != 6) 
            return;
        // Переназначаем переменные для распределенного рандома (на тот случай, если настройки поменяются).

        // Изначально у каждого игрока по 1 очку, так как начальные клетки -- это пустые блоки.
        // Опять же, чтобы соответствовать настройкам.
        n = MapGenerator.n;
        m = n;
        map = new Square[n, m];
        
        for(int i = 0; i < n; i++){ // Цикл прохода по "строкам" или по условной оси Ох.
            for(int j = 0; j < m; j++){ // Цикл прохода по "столбцам" или по условной оси Оу.
                    // Здесь мы n раз проходим по всем j от 0 до m, тем самым проходим каждый квадрат карты. (Если кому-то покажется сложным

                block.GetComponent<SquareChanger>().a = i; // Присваиваем блоку первый индекс (по оси Ох или по "строкам")
                block.GetComponent<SquareChanger>().b = j; // Присваем блоку второй индекс (по оси Оу или по "столбцам")

                    // Выгружаем этот игровой объект на карту с координатами соответствующими его индексу в матрице.
                    // Здесь учитывается размер блока и расстояние между клетками.
                var rotate = block.transform.rotation;
                // rotate.y = 0.28f;
                float x = (block_lenght * 3.0f / 2.0f * i), y = 0, z = block_lenght * (float)Math.Sqrt(3) * j;
                x -= 10;
                z -= 10;
                if(i % 2 == 1)
                    z += block_lenght * (float)Math.Sqrt(3) / 2.0f;
                
                Instantiate(block, new Vector3(x, y, z), rotate);

                MapGenerator.map[i, j].owner = -1; // Присваем owner -1 для того чтобы блок понимал, что он ничейный.
                // //Debug.Log(dist);
            }
        }

        // map[0,0].owner = 0; // В блоке с индексом 0,0 ставим принадлежность синего игрока (то есть это теперь блок синего).
        // map[n-1, m-1].owner = 1; // В последнем блоке матрицы ставим принадлежность красного.
        // map[0, 0].level = 0;
        // map[n-1, m-1].level = 0;
    }
}
